# 递归

方法递归，简而言之就是方法本身自己调用自己；

咬文嚼字的分析就是两个过程：“递“过程和”归“过程，所有的递归问题都能用地推公式标识.例如斐波拉契数列就能用递推公式表示：
$$
f(n) = f(n-1) +f(n-2)其中fn(0)=1,f(1)=1
$$
转换成代码就是

```c#
public static int FibonacciRecursively(int n){
  	if(n<2) return n;
  	return FibonacciRecursively(n-1) + FibonacciRecursively(n-2);
}
```

递归问题要满足三个条件：

- 一个问题可以分解成多个子问题的解；子问题就是规模更小的问题（逻辑不变）
- 这些被分解的子问题，除了规模不一样之外，解决思路一样
- 存在条件来终止递归；这个好理解，因为自己调用自己总不能无线循环下去，所以必须有终止条件。

我们来切换一个思考场景：假如这里有N(>1)个台阶，人上台阶每次只能跨一个或者两个，那么有多少种走法能到顶上呢？

我们先分解问题，第一个台阶的走法只有两种，第一种是走一个台阶，第二种是走两个台阶；那么n个台阶的走法就是等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法；

所以用公式表示就是
$$
f(n) = f(n-1)+f(n-2)
$$
满足终止条件的就是当只有一个台阶的时候就只有一种可能那就是f(1)=1，f(2)=2

所以这个时候就很容易看出这种走楼梯的思想也是斐波拉契数列的体现。

## 递归的陷阱

