# 二叉树

首先思考一个问题：**二叉树的存储有几种方式？什么样的二叉树适合用数组来存储？**

## 什么是树

树是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。具有以下特点：

1. 每个结点有零个或多个子结点；
2. 没有父结点的结点称为父结点；
3. 每一个非跟结点有且只有一个父结点；
4. 除跟结点外，每个子结点可以分为多个不相交的子树；

我们用图来更好的理解一下

![](https://static001.geekbang.org/resource/image/b7/29/b7043bf29a253bb36221eaec62b2e129.jpg)

让我们在用一张图来认识一下父结点、子结点、兄弟结点、跟结点、叶子结点（叶结点）

![](https://static001.geekbang.org/resource/image/22/ae/220043e683ea33b9912425ef759556ae.jpg)

A 结点就是 B 结点的**父结点**，B 结点是 A 结点的**子结点**。B、C、D 这三个结点的父结点是同一个结点，所以它们互称为**兄弟结点**。没有父结点的结点称为**跟结点**，也就是图中的结点 E。我们把没有子结点的结点叫做**叶子结点**或**叶结点**，如果上图中的 G、H、I、J、K、L都是叶子结点。

关于树还有几个概念：

1. 结点的高度 = 结点到叶子结点的最长路径（**边的个数**）
2. 节点的深度 = 跟结点到这个节点所经历的**边的个数**。
3. 节点的层数 = 节点的深度 + 1。
4. 树的高度 = 跟结点的高度。

我们继续用图来表述一下

![](https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg)



## 二叉树

二叉树势每个结点最多有两个子树的树结构。通常子树被称为 “左子树” 和 “右子树”。二叉树常被用于实现二叉查找树和二叉堆。

如何遍历二叉树结点？方法有四种，最常用的是前三种：

- 前序遍历是指，先访问跟，再先序遍历左（右）子树，最后先序遍历右（左）子树。
- 中序遍历是指，首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。
- 后续遍历是指，首先后续遍历左（右）子树，再后续遍历右（左）子树，最后访问根
- 层次遍历是指，按照层次访问，通常用队列来做。访问根，访问子女，在访问子女的子女（越往后的层次越低）（两个子女的级别相同）。

用图片来举个例子：

![](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg)

**实际上，二叉树的前、中、后序遍历就是一个递归的过程**。比如，前序遍历，其实就是先打印跟结点，然后再递归地打印左子树，最后递归地打印右子树。

有递归就一定有递推公式

```
前序遍历的递推公式
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式
postOrder(r) = postOrder(r->right)->postOrder(r->left)->print r
```

### 时间复杂度

从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，根节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。

### 满二叉树和完全二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层（1～h-1）的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

完全二叉树具有以下两个性质：

1. 所有的叶结点都出现在第k层或k-l层（层次最大的两层）。
2. 对任一结点，如果其右子树的最大层次为L，则其左子树的最大层次为L或L+l。

## 散列表与二叉树

散列表的时间复杂度是 O(1)，比二叉树这种数据结构要高效得多，那为什么不用散列表来替代二叉树呢？

有没有什么情况下是散列表无法做的，而二叉树可以做的？

### 二叉查找树

二叉查找树顾名思义，其就是用来快速查找的，不仅仅是快速查找，也能做到高效的删除数据与新增数据。

首先理解二叉查找树有什么特点：

**再树的任意一个结点，其左子树的每个结点的值永远小于右子树的任意结点的值。反过来，右子树的值都比左子树的值要大。**

![](https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg)

接着我们来看下是如何新增，查找，以及删除的

**查找**：我们假设要查询 x 值，那么我们先从跟结点开始查其，如果这个值比跟结点小，那么就递归遍历左子树查找目标值，如果大于跟结点，则再右结点递归查找树，等于跟结点就返回这个值。

我们用 C# 代码来表示这个查询过程：

```c#
public class BinarySearchTree {
    public Node tree;
    //二叉查找树查找元素
    //因为二叉查找树左子树的元素都比根节点小，右子树的元素都比根节点的值大，且树种元素不存在重复值。
    public Node Find(int data) {
        Node p = tree;
        while (p != null) {
            if (data < p.Data) p = p.Left;	//如果小于根结点，则递归遍历左结点查找目标值
            else if (data > p.Data) p = p.Right;//大于跟结点，遍历右子树递归查找值
            else return p;//等于跟结点，返回即可
        }
        return null;
    }
}
```

**插入**：二叉查找树的插入过程与查找过程类似，从跟结点与插入的元素进行比较，大于则往右子树递归查找，如果找到为空的结点，即是插入的位置。如果小于则往左子树递归查找，知道查找子结点为空的位置插入。

> 注意：这里会存在插入值相同的情况，插入过程有所不同。我们暂且不讨论这种情况（下同），后面会提到。

```c#
public void Insert(int data){
    if(tree == null){
        tree = new Node(data);
        return;
    }
    Node p = tree;
    while(p != null){
        if(data > p.data){	//大于结点，右子树遍历查找位置
            if(p.Right == null){
                p.Right = new Node(data);
                return;
            }
            p = p.Right
        }else {
            if(p.Left == null){
                p.Left = new Node(data);
                return;
            }
            p = p.Left;
        }
    }
}
```

**删除**：删除操作比较复杂，针对要删除的结点，分为三种情况要处理。

1. 如果要删除的结点不含子结点，这种情况比较简单，直接删除这个结点即可。怎么删？直接在其父结点上指向待删除的结点指针设置为 null 即可。
2. 要删除的结点含一个子结点（左子结点或右子结点）。我们只需要更新父结点，把原本指向待删除结点的指针指向待删除结点的子结点。
3. 要善书的结点包含两个子结点（左右子结点）。这就复杂了：
   - 查找这个待删除结点的右子树的最小结点
   - 把上一步找到的最小结点的值替换到待删除的结点上
   - 再删除这个最小结点，因为最小结点肯定没有左子树。

用 C# 代码表示：

```c#
public void Delete(int data){
    if(tree == null) return;
    Node p = tree;	//p 点为要删除的数据，初始化指向根结点
    Node pp = null;
    while(p != null && p.Data != data){
        pp = p;
        if(data > p.Data) p = p.Right;
        else p = p.Left;
    }
    if(p == null) return;	//没有找到要删除的目标元素
    //第一种情况：要删除的元素包含两个子结点
    if(p.Left != null && p.Right != null){	//找右子树最小值
        Node minP = p.Right;
        Node minPP = p;	//minPP 表示 minP 父结点
        while(minP.Left != null){
            minPP = minP;
            minP = minP.Left;
        }
        p.Data = minP.Data;	//讲查找的最小子树的值赋值给待删除结点
        p = minP;//下面就变成了删除 minP
        pp = minPP;
    }
    //删除的结点是叶子结点或是只有一个子结点
    Node child; //p 的子结点
    if(p.Left != null) child = p.Left;
    else if(p.Right != null) child = p.Right;
    else child = null;
    
    if(child == null) tree = child;//删除是跟结点
    else if(pp.Left == p) pp.Left = child;
    else pp.Right = child;
}
```

