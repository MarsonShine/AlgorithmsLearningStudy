# 红黑树

红黑树是一种二叉查找树，二叉查找树能快速的查找、插入、删除操作。各个操作的时间复杂度都是 log(n)。但是二叉查找树在频繁的更新过程中，可能会出现树的高度远大于 log2n（2为底数）的情况，导致时间复杂度退化，性能降低。极端情况下，会退化成链表，时间复杂度为 O(n)。所以我们要引入一个相对 “平衡” 的树结构，也就是今天要讲的红黑树（Red-Black Tree）。

## 定义

在二叉搜索树的基础上，在每个结点上增加一个存储位来表示结点的颜色，红或是黑。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，**红黑树确保没有一条路径会比其它路径长出 2 倍**。

## 性质

一颗红黑树有以下 5 点特征：

1. 每个结点不是红色就是黑色。
2. 根结点是黑色的。
3. 每个叶子结点（NIL）都是黑色的。
4. 如果一个结点是红色的，那它两个子结点就是黑色的。
5. 对每个结点， 从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。

平衡二叉查找树中的 “平衡” 的意思其实就是让整颗树左右看起来比较 “对称”、比较 “平衡”，不要出现左子树（或右子树）很高（矮）的情况，这样树的高度就不会很高，所以相应的查找、插入、删除操作性能不会退化。

## 红黑树的 “平衡”

二叉树很多操作都与树的高度成正比。一颗极其平衡的二叉树（满二叉树或完全二叉树）的高度大约为 lgn，所以如果要证明红黑树的平衡，我们只需要证明它的高度是否趋紧于 lgn。

我们可以用相对简洁的办法粗略的来求证。

**我们首先来把红黑树中的红色结点去掉只剩黑色结点的树**，来看下树的高度是多少？

![](https://static001.geekbang.org/resource/image/7e/ed/7e6ecc308fe44120f30de809822215ed.jpg)

> 注意：红色结点删除之后，有些结点没有父结点，它们会把父结点的父结点作为父结点，所以就成了上图所示（四叉树）

我们根据前面说的红黑树的第五点性质，丛任意结点到可达的叶子结点的简单路径包含的黑色结点数量是相同。

我们从四叉树中取出某些结点，放到叶子结点位置，那么四叉树就变成完全二叉树，所以包含四叉树的高度要比相同结点个数的完全二叉树高度要小。

现在我们知道了只包含黑色结点的 “黑树” 高度，那么我们再把红色结点加回去，高度右会变成多少？

我们根据红色树的第四点特征知道，红色结点肯定不会相邻的。也就是说有一个红色结点就要至少有一个黑色结点，将其它红色结点分开。红黑树包含最多黑色结点的路径最多不会超过 lgn（也就是高度），所以加上红色结点之后，最长路径不会超过 2lgn。

所以红黑树的高度也仅仅比完全二叉树（满二叉树）这种完全平衡的树结构多一倍，在性能上，退化的不明显。

实际上这样推倒出来的结果不精确，实际上红黑树的性能更好。

那么当我们在给这样的红黑树添加或删除数据是，遇到像之前二叉搜索树一样，极端情况下怎么避免退化成链式结构的呢？换句话说就是红黑树如何在频繁的插入与删除操作下还能保持它的 “平衡”。这就是下面紧接着要提到的旋转。

## 旋转

因为在红黑树插入或者删除操作情况下，由于对树结构进行了修改，结果可能有违与之前提到的红黑树的性质，所以我们要为了满足上述五点特征，必须要**改变树中某些结点的颜色以及指针结构**

指针的修改是通过旋转（ratation）来完成的。它能保持红黑色的性质。它又分为左旋和右旋。

### 左旋

围绕着**关注节点**（正在处理的节点，比如插入，删除等）左旋转

以 x 结点（即关注节点）左旋，那么 y 成为该子树的跟结点，x 成为 y 的左子结点，y 的左子结点成为 x 的右子结点（所以右旋就是反过来的）

### 右旋

以 x 节点右旋，y 成为 该子树的根节点，x 成为 y 的右子结点，y 的右子结点成为 x 的左子结点，其他指针指向不变

左右旋转用图表示就是

![](https://static001.geekbang.org/resource/image/0e/1e/0e37e597737012593a93105ebbf4591e.jpg)

> 注意：旋转操作只会发生指针、颜色的改变，其他属性不会改变

## 插入操作的平衡调整

**红黑树规定：插入的结点颜色必须是红色，并且插入的结点必须是叶子结点**

首先讲两种特殊情况，比较好处理：

1. 插入的结点就是根节点，那么只需要更改颜色为黑色即可
2. 插入的结点的父节点颜色为黑色，那么只需要把结点插入到叶子结点即可

除了这两种情况，子树的改变都会违背红黑树的 “5大特征”，所以要围绕这些特征进行调整，插入过程，主要分三种情况，根据不同的情况来进行不同的调整。

### CASE1：如果关注节点是 a，它的叔叔结点 d 是红色

- 将关注节点 a 的父节点 b、叔叔结点 d 的颜色设置为黑色（根据特性1，4）

- 将关注节点 a 的曾祖父结点 c 颜色设置为红色（根据特性1，4）

- 关注节点由 a 变成 a 的曾祖父结点 c

- 跳到case2或者case3

  ![](https://static001.geekbang.org/resource/image/60/40/603cf91f54b5db21bd02c6c5678ecf40.jpg)


### CASE2：如果关注节点是 a，它的叔叔结点是黑色，关注节点 a 是其父节点 b 的右子结点

- 关注结点 a 变成结点a 的父结点
- 沿着关注结点 c 左旋
- 跳到case3

![](https://static001.geekbang.org/resource/image/44/ad/4480a314f9d83c343b8adbb28b6782ad.jpg)

左旋过程：结点 a 成为结点 b 的父节点，结点 a 成为 b 结点的左子结点，结点 a 的右子结点成为 b 的左子结点，其他指针不变。

### CASE3：如果关注节点 a，它的叔叔结点是黑色，关注节点 a 是其父结点 b 的左子结点

- 关注结点 a 变成 a 的曾祖父结点 c
- 围绕关注结点 c 右旋
- 根据红黑树颜色特征，更改相应的颜色

![](https://static001.geekbang.org/resource/image/04/12/04650d9470b1e67899f5b8b7b8e33212.jpg)

多层级的右旋过程：

**围绕关注结点 c 右旋，其中结点 c 的子节点 b 以及 b 的子结点 a 都视作关注结点 c 的左子树结点，我们把（b，a）看做是关注结点 c 的左子结点 A。根据右旋公式可知**

**结点 A 成为 结点 c 的根节点，结点 c 成为 结点 A 的右子结点，A 的右子结点成为结点 c 的左子结点，其他指针变量不变。**

有根据红黑树颜色特征，根结点必须是黑色，如果一个结点是黑色，那么这个结点的两个子结点都是红色，叶子结点都是黑色，来对结点进行颜色调整。

## 删除操作的平衡性调整

删除要比插入复杂得多，主要分为两个部分的平衡性调整

1. 针对删除结点的初步调整
2. 对关注结点的二次调整

第一步只是保证结点被删除之后要保证红黑树的最后一点特征：**从结点到任何一个叶子结点的可达简单路径的黑色结点数保持相同**

第二步是要满足红黑树的第三个特征，不存在相邻的两个红色结点。

### 针对删除结点初步调整

主要操作主要分为三种情况

> 注意：
>
> 下图的带一半黑一半红的结点代表这个结点可以为红色也可以为黑色；
>
> 结点左上角实心点标识除了结点本来的颜色在加上左上角圆点的颜色；
>
> **后继结点：树中序遍历后的该结点位置的下一个位置的结点**

#### CASE1：如果要删除的结点是 a,它只有一个子结点 b

- 删除结点 a，并且把结点 b 替换到结点 a 的位置
- 结点a 只能是黑色，结点 b 只能是红色（根据特征1,2）以及新插入的结点必须是红色，所以要把结点 b 涂黑
- 调整结束，不需要二次调整。

![](https://static001.geekbang.org/resource/image/a6/c3/a6c4c347b7cbdf57662bab399ed36cc3.jpg)

#### CASE2：如果要删除的结点 a 有两个非空子结点，并且它的后继结点就是结点 a 的右结点 c

- 结点 a 的后继结点就是右子结点 c，那右子结点 c 肯定没有左子树。那就删除结点 a，并将 a 的右子节点替换到结点 a 的位置
- 把结点 c 的颜色设置为跟结点 a 相同的颜色。
- 如果结点 c 是黑色，为了不违反红黑树的最后一条定义，于是就给结点 c 的右子结点 d 多加一个黑色，所以结点 d 就变成了 “红-黑” 或者 “黑-黑”
- 这个时候，关注节点变成了结点 d，第二步的调整就要对关注节点 d 来做

![](https://static001.geekbang.org/resource/image/48/4e/48e3bd2cdd66cb635f8a4df8fb8fd64e.jpg)

#### CASE3：如果要删除的是结点 a ，它有两个非空子结点，并且结点 a 的后继结点不是右子结点

![](https://static001.geekbang.org/resource/image/b9/29/b93c1fa4de16aee5482424ddf49f3c29.jpg)

- 找到后继结点 d 并删除，删除后继结点的过程参照 CASE1
- 结点 a 替换成 后继结点 d
- 把结点 d 的颜色设置跟结点 a 的颜色相同
- 如果结点 d 是黑色，不满足最后一条特征，所以要给结点 d 的右子结点 c 多加一个黑色
- 关注节点变成了结点 c，第二步对关注节点进行调整

### 针对关注节点进行二次调整

经过删除结点的初步调整来看，关注节点变成了 “红-黑” 或是 “黑-黑” 结点。针对这个关注节点，又分为四种情况来进行二次调整，主要目的是为了满足红黑树特性中的第三种——不能存在相邻的红色结点。

#### CASE1：如果关注节点是 a，它的兄弟结点 c 是红色的

- 围绕关注结点 a 的父节点 b 左旋转
- 关注结点 a 的父结点 b 和曾祖父结点 c 颜色互换
- 关注节点不变
- 继续从这四个 CASE 中查找合适的规则来调整

![](https://static001.geekbang.org/resource/image/ac/91/ac76d78c064a2486e2a5b4c4903acb91.jpg)

多层级左旋转过程：（c,e 成为结点 b 的根节点，b 成为 c,e 的左子结点，c,e 的左子结点 d 成为了 b 的右子结点，其他不变）

#### CASE2：如果关注结点是 a，它的兄弟结点 c 是黑色的，并且 c 的左右子结点 d，e 都是黑色的

- 关注结点 a 的兄弟结点 c 的颜色变成红色
- 从关注结点 a 中去掉一个黑色，这个时候关注结点就是单纯的红色或者黑色
- 给关注结点 a 的父结点 b 添加一个黑色
- 关注结点从 a 变成 b
- 继续从四种 CASE 规则来调整

![](https://static001.geekbang.org/resource/image/ec/ec/eca118d673c607eb2b103f3476fb24ec.jpg)

#### CASE3：如果关注结点是 a，它的兄弟结点 c 是黑色的，并且 c 的左结点 d 是红色，c  的右子结点是黑色

- 围绕关注结点 a 的父结点 b 右旋转
- 结点 d，c 颜色互换
- 关注结点不变
- 跳到 CASE4

![](https://static001.geekbang.org/resource/image/44/af/44075213100edd70315e1492422c92af.jpg)

#### CASE4：如果关注结点是 a，它的兄弟结点 c 是黑色的，并且 c 的右子结点是红色的

- 围绕关注结点 a 的父结点 b 左旋转
- 关注结点 a 的兄弟结点 c，以及关注结点 a 的父结点 b 设置成相同颜色
- 将关注结点 a 的父结点 b 的颜色设置为黑色
- 从关注结点 a 去掉一个黑色，结点 a 就变成纯色
- 将关注结点 a 的叔叔结点 e 设置为黑色
- 调整结束

![](https://static001.geekbang.org/resource/image/5f/44/5f73f61bf77a7f2bb75f168cf432ec44.jpg)

### 注意点：当没有碰到这四种情况怎么办？

![](https://static001.geekbang.org/resource/image/d9/c9/d9d1ce7d6bf3da4888f39f9d15be99c9.jpg)

当我们新插入的结点如上图所示时，会发现不适合上面说的三种平衡情况，这时我们可以在所有叶子结点公用一个 NIL（空黑色节点）这样的话，就满足 CASE2 了。在《算法导论》中把这个公用（节省内存）的 NIL 结点称之为哨兵结点











