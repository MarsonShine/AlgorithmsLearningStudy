## 散列表

首先思考一个问题，world 文档中有一个单词检查功能，当你拼接单词错误的时候，world 文档会给你写的单词红色的下划线予以提示。那么这个功能是如何实现的呢？

其实这就用到了我们现在讲的散列表（Hash Table）。

### 什么是散列表

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表是数组的一种拓展，由数组演化而来。**

我们用生活上实际的例子来说明散列表的思想，就以我上大学时候班级学号为例，我们计科班总共有 23 人（人是真的少，并且只有一个班），那么学号暂且是 01 到 23，每个数字就代表，能查到我们班级每个人的信息。所以我们把学号当作数组的下标，学生信息作为值存到数组里。那么当我们查询学号为 x 的学生信息时，只需要将下标 x 的数组元素取出来即可，时间复杂度时 O(1)。

这个例子就用到散裂的思想。学号是自然数，与数组的下标形成一一映射，所以利用了数组下标随机访问，O(1) 的复杂度很容易就能查到学号对应的学生信息。

可能你觉得这个例子还不够直观，那么我们把情景升级一下。

假设学号不可能用这么简单的数字就能代表一个人独一无二的信息，的确是这样，因为别的班级如果学号也是这样，那么你就无法根据学号获取唯一的信息了。我们把学号规则改一下，比如我是 2010 年入学的计科 1001 班，我们把计算机科学专业用 01 表示，比如我的学号是 11，那么综合起来就是 201001100111，最后两位依旧还是原来的学号编号。这个时候我们该如何存储学生信息，才能够通过编号快速查找信息呢？

思路还是跟前面类似。尽管我们不能直接把学号当作下标存储，但是我们可以截取学号的最后两位来当作数组下标，来存取学生信息。当通过学号查询信息的时候，我们通过同样的截取方法获取最后两位作为数组下标，来读取数组中的数据。

这就是典型的散列思想。其中，我们把学生的学号编号（最后两位）叫做键（Key）或关键字。我们用它标识学生。我们把学号转换为数组下标的映射方法称为 **散列函数** 或哈希函数。而通过散裂函数得到的值就是散列值（或叫哈希值）。

通过上述总结出这样的规律：散列表就是用数组支持的下标随机访问的时候，我们通过散列函数把键值转换为散列值，从而在数组中找到对应的位置取出值。

### 散列函数

从上面描述来看，散列函数是至关重要的。

散列函数，顾名思义就是一个函数。我们可以定义为 **hash(key)** ，其中 key 是键值，hash(key) 返回的是散列值。我们把上面的截取最后两位的散列函数用代码表示就是

```c#
int hash(string key){
    //获取最后两位
    string lastTwoChars = key.SubString(key.Length - 2,key.Length);
    //将截取的字符转换为整数
    int hashValue = int.Parse(lastTwoChars);
    return hashValue;
}
```

在刚刚举的例子中，散列函数比较简单，就是简单的数字运算，比较容易想得到。但是假使我们的学号含有字母任意组合怎么办呢？该如何构造散列函数？主要有 3 点基本要求

1. 散列函数计算的散列值是一个非负整数。
2. 如果 key1 = key2，那么 hash(key1) == hash(key2)。
3. 如果 key1 ≠ key2，那么 hash(key1) ≠ hash(key2)。

第一，二点都好理解，第三点要求起来是合乎情理，但是实际情况是我们很难找到一个不同的 key 对应的散列值不同的情况，这几乎是不可能的。就像著名的 MD5、SHA、CRC等哈希算法，也无法完全避免**哈希冲撞**。而且，存储空间有限，也会加大散列冲突的概率。

所以我们无法设计一个无冲突的散列函数。那么我们该如何尽量避免散列冲撞呢？

### 散列冲撞

常用的有两种：开放寻址法（open addressing）和链表法（chaining）。

**开放寻址法**的核心思想是：如果出现了散列冲突，我们将重新探测一个空闲位置，将其插入。那么如何重新探测新的空闲位置？有一个简单的方法：**线形探测（Linear Probing）**

当我们往散列表插入新数据时，如果某个键值经过散列函数的出来的位置已经被占用了，我们就从当前位置依次往后找，直到找到空闲位置为止。要注意，如果到尾部都没有找到空闲位置，那么就会从头还是找。

在散列表中查找元素有点类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就依次顺序往后查找。如果遍历到了空闲位置，还没有找到，就说明要查找的元素不在散列表中。

散列表跟数组一样，不仅支持插入，查找操作，还支持删除操作。对于使用线性探测法解决冲突散列表，删除操作稍微有些特别，不能直接把要删除的元素设置为空，为什么呢？

还记得刚刚我之前查找元素的过程么，散列表在查找目标元素时，一单碰到空闲位置，就会认定这个数不存在于散列表中。但是，这个空闲位置是我们后来删除的，就会导致原来的算法失效。本来存在的数据会被认定不存在，那么这个问题该如何解决呢？

我们可以将要删除的元素标记为 deleted。当线性探测查找时，遇到标记为 deleted 的位置，并不是停下来，而是继续往下探测。

这样可能你们都有一个疑问，当数据量变大时，散列冲突存在的可能性会越来越大，空闲位置就会越来越少，线性探测的事件就会越来越长，在极端情况下，我们可能需要探测整个散列表，所以最坏情况时间复杂度时O(n)。同理，删除和查找时，也会因为线性探测整个散列表，才能找到要删除或查找的元素。

这个时候我们就要用到另外两个探测方法：二次探测（Quadartic probing）和双重散列（Double hasing）。

所谓**二次探测**，其实跟线性探测法类似，只是有步长。线性探测的步长是 1，而它的探测下标就是 hash(key)+0 ，hash(key)+1，hash(key)+2......而二次探测的步长就变成了原来的 “二次方”，也就是说，它的探测下标就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2……

所谓**双重散列**，意思就是说不仅要使用一个散列函数，还要使用一组散列函数：hash(key)，hash2(key)，hash3(key)…… 我们先用第一个散列函数，如果算出来的散列值对应的数组存储位置被占用，在用第二个散列函数，以此类推，直到找到空闲位置。

不管采用哪种方法，当空闲位置越来越少时，散列冲突的概率就会越高。所以为了尽可能保证散列表的操作效率，一定情况下，我们会保持散列表中有一定比例的空闲位置。我们用**装载因子（load factor）**来表示空位的多少。

```
散列表的装载因子 loadfactor = 填入表中的元素个数 ／ 散列表的长度
```

装载因子越大，说明空闲位置越小，冲突越多，散列表的性能就越低。

**链表法**是一种更加常用的解决散列冲突的方法。