# 排序

## 如何分析一个“排序算法”

排序有很多种，常用的就有：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、堆排序、基数排序、桶排序等。不常见的又比如猴子排序、睡眠排序、面条排序等

如何分析一个排序算法呢，有三个因素要考虑。

### 排序算法的执行效率

1. **最好情况、最坏情况、平均情况时间复杂度**；因为一组数据可能已经就是排过序了（完全有序），有的是完全无序。有序度不同的数据，排序的执行时间肯定是有影响的，我们要知道在不同排序度的性能情况。
2. **时间复杂度的系数、常数、低阶**；时间复杂度反应的数据规模n很大的时候的一个增长趋势，所以在这种情况会忽略系数，常数，低阶。但是在我们实际开放中，我们几乎很少有这种大规模的数据。所以在小规模数据时，特别是在同阶对比时间复杂度时，系数、常数、低阶都要考虑进来。
3. **比较次数和交换（或移动）次数**；基于比较的排序算法的执行过程，会有两个操作，一种是元素的比较大小，另一种是元素交换或移动。所以在比较时间复杂度的执行效率的时候，应该把比较次数和移动或交换的次数也考虑进去。

### 排序算法的内存消耗

衡量一个算法的内存消耗，可以用空间复杂度。不过，针对排序算法的空间复杂度，还有一个概念：**原地排序（Soreted in place）**。原地排序算法，就是特指空间复杂为O(1)的排序算法。冒泡、插入、选择排序都是原地排序算法。

### 排序算法的稳定性

什么是算法的稳定性：就是在一个集合中，存在相同的值的元素，经过排序后，相等元素之间原有的顺序没有发生改变，我们就称这个为稳定性。同时我们把这种算法称为**稳定排序算法**。先从简单的整形数组举例：

[2,9,3,4,8,3] 按照排序之后之后为 [2,3,3,4,8,9]

这里面有两个3，经过排序之后，如果这两个3顺序没有改变，这个就是排序就是稳定的。相反，如果这两个3的顺序改变了那就非稳定的。当然从整数上是看不出到底哪个3在前，哪个3在后；在举个平常业务上的例子，这里有一个订单集合，要求按照订单金额从小到大的顺序排序，其中金额相同的订单按照订单时间排序。

“先按照订单时间排序，然后遍利排序后的集合，把金额相同的订单再按照订单时间排序“

这种实现起来比较容易理解，但是复杂。

但是我们可以借助稳定排序算法，能够在保持第一次排序的顺序进行第二次排序。具体思路是：我们先按照订单时间排序，第二次排序我们用稳定排序算法把订单金额进行排序，所以经过第二次排序之后，相同的订单仍然保持以时间早晚的顺序排序。

## 冒泡排序（Bubble Sort）

冒泡排序之后操作两个相邻的数据，比较大小是否满足比较条件。如果满足就互换，一次冒泡操作可以至少让一个元素移到正确位置。

假设这里有[4,5,6,1,2,3]一组数据，如果你要把6放到正确的位置要6次冒泡（从4，5开始比较）

```C#
public void BubbleSort(string[] array){
    if(array.Length < 1) return;
    for(int i = 0; i < array.Length; i++){
        for(int j = 0; j < array.Length; j++){
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
    }
}
```

这里还可以优化，因为每经过一次冒泡，那么第二次冒泡数据的比较就可以排除第一次冒泡的数据，以此类推，所以在第二个for循环判断条件就可以改为 `for(int j = 0; j < array.Length - i - 1; j++)` ;除此之外，根据这个思路我们还可以继续优化，如果其中某一次冒泡没有发生数据移动，就说明这个数据已经是完全排序了。修改代码如下

```c#
public void BubbleSortBetter(string[] array){
    if(array.Length < 1) return;
    for(int i = 0; i < array.Length; i++){
        bool flag = false;
        for(int j = 0; j < array.Length; j++){
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
                flag = true;
            }
        }
        if(!flag) break;
    }
}
```

集合我们上面说的分析排序的三点；

1. 冒泡排序是否是原地排序？

   因为冒泡算法都是相邻的两个元素比较，只需要常数级的临时变量空间，所以空间复杂度为O(1)，因此时原地排序

2. 是否是稳定的？

   当碰到两个相同元素时，我们可以在满足比较条件下选择在两个元素之前或之后插入数据，所以前后的顺序是不变的，因此是稳定的。

3. 时间复杂度时多少？

   当最好情况下，数据已经是完全排序，所以只需一次冒泡即可，时间复杂度为O(n)。最坏情况是数组是倒序排列，那么时间复杂度为O(n*n)；最好，最坏时间复杂度容易分析；那么平均时间复杂度是多少，如果用概率论方法定量分析平均时间复杂度是非常复杂的，且要求数学功底深厚，我们可以用《算法导论》中平均时间复杂分析小结中概括：

   > “平均情况”往往与最坏情况大致一致。假定随机选择n个数病应用插入排序。需要多长时间确定在子数组A[1..j-1]的什么位置插入元素A[j]？平均来说，A[1...j-1]中的一半元素小于A[j]；一半元素大于A[j]。所以，平均来说，我们检查子数组A[1...j-1]的一半，那么tj大约为 j/2。导致平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。

   我们这里用另一种“不是那么准确但大多数情况适用”的方法分析：通过“**有序度**”和“**逆序度**”两个概念进行分析。

   有序度是指数组中具有有序关系的元素对的个数。有序度用数学公式表示就是：

   ```
   有序元素对：a[i] <= a[j],如果 i < j。
   ```

   举个例子最容易说明：[2,3,4,1,6]

   这组数组的有序度为6，分别是(2,3)、(2,4)、(2,6)、(3,4)、(3,6)、(4,6) ；

   如果是一个倒叙的数组[6,5,4,3,2,1] 那么有序度就是0；如果是一个完全有序的数组，则为 **n * (n - 1) / 2**。这种完全有序的称之为“**满有序度**”。

   而逆序度与之相反，用数学公式表示为：

   ```
   逆序度对：a[i] > [j],如果 i < j
   ```

   我们还有一个公式：逆序度 = 满序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度变成为满序度的过程。

   我们举个例子：要排序的数组的初始状态为[4,5,6,3,2,1]，其中有序对有(4,5)(4,6)(5,6)，所以有序度为3。n=6，所以排序完成之后的终态满有序度为 n * (n - 1) / 2 = 15。

   冒泡排序有两个操作，一个是比较，一个是交换。每交换一次，有序度+1。不管算法怎么改进，交换的次数是固定的，即逆序度，在这个例子中就是 n * (n - 1) / 2 - 3 = 15 - 3 = 12。通过上面提到的复杂度分析，我们很容易得知最好情况复杂度为O(n)；最坏复杂度为O(n^2)；平均复杂度，我们根据前面《算法导论》提到的分析方法，我们假设取个中间值[0,n * (n - 1) / 2]，即 n * (n - 1) / 4 次交换操作，由于因为n的规模无限大的时候也就是前面提到的结果为一个二次函数，即 O(n^2)。

   ## 插入排序(Insertion Sort)

   我们可以先考虑这个问题，在一个有序的数组里，如何插入一个新的数据呢，如何在保持有序的情况下插入新数据？很简单，遍历数组找到数据应该插入的位置，直接将其插入即可。

   ![https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg](https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg)

我们可以通过这种一直保持有序的插入操作，这种算法称之为“插入排序算法”。

那么具体如何实现呢？

首先，我们把一个待排序的数组分两个区间，一个是一排序区间，另一个是未排序区间。在初始状态，已排序区间为第一个数，然后在未排序区间取个数，在已排序区间找到合适的位置将值插入，并保证已排序区间是有序的。这样重复操作，一直到待排序区间为空即终止。如下图所示，红色为已排序区间，黄色为未排序区间

![](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)

我们可以发现，插入排序总共也有两个操作：“**比较**”和“**移动**”。因为我从未排序区间取一个数在已排序区间经过比较找到合适的位置插入时，我们要把该位置之后的数据往后移一位，这样才能插入数据。

对于不同的查找插入点方法（从头到尾，从尾到头），元素比较时有区别的，但是数据移动是固定的，也就是逆序度。我们可以从图中看明白为什么数据移动个数就等于逆序度，满有序度为 n * (n - 1) / 2 = 15，初始有序度为 5，所以逆有序度为10。插入排序移动的数据个数为 10 = 3 + 3 + 4；

![](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

插入排序算法实现代码为

```c#
public void InsertionSort(int[] array){
    if(array.Length < 1) return;
    for(int i = 1; i < array.Length; i++){
        int value = a[i];
        int j = i - 1;
        for(; j >= 0; j--){
            if(a[j] > value){
                //移动数据
                a[j + 1] = a[j];
            }else{
                break;
            }
        }
        a[j + 1] = value;
    }
}
```

1. 插入排序是否是原地排序算法？

   根据前面冒泡的算法分析，我们知道插入排序不消耗额外的存储空间，所以空间复杂度为O(1)；即原地排序算法。

2. 插入排序是否时稳定的？

   我们在遇到两个数据相同时，满足判断条件，我们可以选择插入最后一个相同数据的后面，这样顺序就不会改变，即时稳定排序算法。

3. 插入时间复杂度是多少？

   最好情况时间复杂度为：当已经时满排序度数组时，我们不需要移动数据，我们只需要每次比较一个数据就能确定插入的位置。所以时间复杂度为O(n)；最坏情况是完全逆序数组时，每次比较数据确定插入的位置时，还要进行大量的数据移动工作，所以最坏时间复杂度为O(n * n)；因为我们在数组中插入一个数组的概率都是一样的，所以平均复杂度为(1+2+3+...+n) / n = O(n)；所以数据规模为n时，就要插入n次，即平均时间复杂度为O(n^2)；

## 选择排序

选择排序思想与插入排序类似，也是氛围已排序区间和未排序区间，但是在取数据时是有选择的（选取未排序区间数据中最小／大的），所以称之为“选择排序算法”。

![](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

从之前两个排序算法的分析以及从图中我们可以得知

1. 选择排序的空间复杂度为O(1)，即为原地排序算法。
2. 由于每次比较满足条件都是会前后交换位置，所以当遇到相同数据时，相同数据的顺序一定会发生变化。即选择排序算法不是稳定的。
3. 最好时间复杂度，最坏时间复杂度，平均时间复杂度都是O(n^2)；

## 拓展-希尔排序

在插入排序算法的基础之上，我们可以根据步长遍历数组，比较满足条件之后，由原来一次只移动一个数据变为了一次性移动步长数个数据。

> 算法先将要排序的一组数按某个[增量](https://baike.baidu.com/item/%E5%A2%9E%E9%87%8F)d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当[增量](https://baike.baidu.com/item/%E5%A2%9E%E9%87%8F)减到1时，整个要排序的数被分成一组，排序完成。
>
> 一般的初次取序列的一半为[增量](https://baike.baidu.com/item/%E5%A2%9E%E9%87%8F)，以后每次减半，直到增量为1。

具体实现代码为

```c#
public void ShellSort(int[] array){
    if(array.Length < 1) return;
    int inc = array.Length / 2; //步长
    while(inc >= 1){
        for(int i = inc; i < array.Length; i++){
            int temp = array[i];	//被inc分成两部分的第二部分的第一个数
            int j = i - inc;	//被inc分城两部分的第一部分的第一个数
            while(j >= 0 && array[j] > temp){
                //移动数据
                array[j + inc] = array[j];
                j -= inc;
            }
            array[j + inc] = temp;
        }
        inc = inc / 2;
    }
}
```

> 步长数如何选取呢？
>
> 在《算法》一书中对希尔排序是这么定义的：希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组称为 h 有序数组。换句话说，一个 h 有序数组就是 h 个互相独立的有序数组组合在一起形成的一个数组。所以对于步长值的选择可以如下：
>
> ```
> int length = array.length;
> while (h < length/3) h = 3 * h + 1; //1, 4, 13, 40, 121, ...
> ```
>
> 为此，还总结为了一个性质：**使用递增序列 1, 4, 13, 40, 121, 364…的希尔排序所需的比较次数不会超出 *N* 的若干倍乘以递增序列的长度。**
>
> 当然也可以简单的通过 length/2 表示步长数，2n + 1 等。

