# 求缺失的第一个正整数

这是 [leecode-41](https://leetcode-cn.com/problems/first-missing-positive/) 的数组结构的算法题。

其实这道题我想了很久，尝试了我能想到的各种方法总是在特定的数组下不行。后来去看题目解析，才知道我没有完全读懂题目的意思。现在回头来重新梳理一下这道题。

Q：给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

其实题目还规定了 O(n) 时间复杂度和常数级复杂度。

在解决一个问题前，如果短时间没有想到好的解决方案，那么就从最简单最 “low” 的思路去解决问题（可笑的是，我连这个所谓的最 low 的方式都没有想到）。

首先来分析这个题目，这个题目还给几个例子：

```
1:
输入：nums = [1,2,0]
输出：3

2:
输入：nums = [3,4,-1,1]
输出：2

3:
输入：nums = [7,8,9,11,12]
输出：1
```

因为题干要求找的数必须是正整数，所以负数和 0 不是我要找的。**也就是说找的数一定是 [1, ∞] 之中**。那么我直接通过穷举这个区间就可以得知第一个丢失的最小正整数了。因为题目给出了条件，最大数就是 2^31，所以从 1 开始直到 2^31

```go
func firstMissingPositive(nums []int) int {
    var i int = 1
    for i < 2<<31 {
      b := true
      for j := 0; j < len(nums); j++ {
        if i == nums[j] {
          b = true
          break
        } else {
          b = false
        }
      }
      if !b {
        return i
      }
      i += 1
    }
    return i
}
```

那么这上面其实可以进一步优化，每次外围的循环都要循环 len(nums) 次，所以我们可以用哈希表存储起来，每次外层遍历之后只需要比较一次即可：

```go
func firstMissingPositive(nums []int) int {
  flag := map[int]bool{}
	for i := 0; i < len(nums); i++ {
		flag[nums[i]] = true
	}
	for i := 1; i < 2 << 31; i++ {
		if _, ok := flag[i]; !ok {
			return i
		}
	}
  // 不存在
  return 1
}
```

再接下来的优化真的需要脑瓜子非常灵活了。

我们再接着分析题干，假设我们给定的数组是 `[3,4,-1,1]`。**数组长度是 4，要想找到最小的最大正整数，我们知道肯定长度为 4 的数组最小正整数必定是 [1,4] 中的一个**。进一步再想一下，如果一个长度为 n 的数组里面，有元素是大于 n 的，那么势必就有 [1,n] 中的值不在目标数组里。我们现在要做的就是要如何找到这个数值。

上面我们用到了哈希表，其实我们可以**通过数组下标索引+值来构成一个哈希映射关系**来协助我们完成比较。

1. 首先排除负数和大于数组长度的值
2. 因为我们要找的数值一定在 [1, n] 这个范围内（数组长度为 n）。那么我们就把目标数组中的在范围的元素标记起来。实现方式就是数组元素做下标，用相反数来表示。
3. 找到第一个非负值所在的**数组下标值**就是目标值
4. 如果没有，说明目标数组中的值是 [1,n] 连续值，所以丢失的最小正整数就是 n+1。

```go
func firstMissingPositive(nums []int) int {	// 1. [3,4,-1,1]
	n := len(nums)
	// 由于找出的数一定是 [1, nums.length]
	// 找出是负数的以及大于数组长度的值，标记为 n + 1
	for i := 0; i < n; i++ {	// 2. [3,4,5,1]
		if nums[i] <= 0 {
			nums[i] = n + 1
		}
	}
	// 前面提到要找数必定在 [1, n] 内
  // 即然后把目标数组的数在此范围的“标记”出来，这里将数所在的索引对应的值赋值为负数(因为在这个范围内的话，那么对应的下标就必定存在数值，又因为之前的逻辑将非负的值全部置为n+1，所以就可以通过负数来表明这个值是在范围内的)。这样就能通过查询为负的索引（为什么用目标数所在的位置，主要目的是起到排序作用）值就能知道第一个非负值的索引(所以是取的绝对值)就为目标最小的数字。
	for i := 0; i < n; i++ {
		loc := abs(nums[i])
		if loc <= n {
			nums[loc-1] = -abs(nums[loc-1])	// [-3,4,-5,-1]
		}
	}
	// 查找第一个非负的值所在的位置
	for i := 0; i < n; i++ {
		if nums[i] > 0 {
			return i + 1
		}
	}
}
```

其中主要的难点，想不通的就是第二点，如何将数组中属于 [1, n] 的范围的数值标记起来呢？

**因为在这个范围内的话，那么对应的下标就必定存在数值，又因为之前的逻辑将非负的值全部置为 n+1，所以就可以通过负数来表明这个值是在范围内的。**

那么有了这个思路，其实我们就能想到另一种方案了。

还是以 [3,4,-1,1] 的数组，我们可以**按照下标来排序**，即将目标数组变为 [1,-1,3,4]。这样我们就能知道丢失的最小正整数是 2。

```go
func firstMissingPositive(nums []int) int {
  n := len(nums)
	for i := 0; i < n; i++ {
		for nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i]-1] {
			nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
		}
	}
	for i := 0; i < n; i++ {
		if nums[i] != i+1 {
			return i + 1
		}
	}
	return n + 1
}
```