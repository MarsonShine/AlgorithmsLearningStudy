## 桶排序与基数排序

### 桶排序

顾名思义，就是要把要排序的数据放到这些有序的桶里，然后对桶里的数据单独进行排序。桶内排完序之后，只需要依次取出来即可。

桶排序的时间复杂度时O(n)，我们用之前分析的方法来分析下

如果排序的数据有n个，我们把它们均匀分到m个桶内，每个桶内就有 n/m=k 个元素。每个桶内我们对数据进行快排，时间复杂度为 O(nlogn) ，所以m个桶的时间复杂度就有 O(m*klogk)，因为 k=n/m 带入表达式得知整个桶排序的时间复杂度为 O(n\*log(n/m))。当桶的个数m无限接近于个数n时，log(n/m) 就是一个非常小的常量，这个时候时间复杂度为O(n)。

那么桶排序效率这么高，是不是可以取代之前提到过的那些算法呢，其实不然，之前分析的数据都是建立在很多假设的前提之下的。桶排序其实限制条件很多，首先桶要能很容易分出来m个桶，并且桶之间有天然的顺序。再者，这里的数据要能 “均匀” 的分摊到m个桶中，如果有一个桶有很多数据，甚至极端情况下，一个桶就有所有数据，那么这个时候算法复杂度就退化为 O(nlogn)。

并且桶一般适合**外部排序**。所谓的外部排序就是数据存储在外部磁盘中，比如有大量的数据，运存无法满足其大小，一次性加载到内存中。

比如我们这里有10GB 的订单数据，我们希望按照订单的金额排序，但是我们电脑内存有限，只有几百M。这时候怎么办呢？桶排序就能满足要求。

我们先扫描订单文件，看订单的金额范围。经过扫描，我们假设最消极金额时1元，最大金额时10万。我们将所有数据放到100个桶里，第一个桶存放[1,1000]，第二个存放[1001,2000]，以此类推，并对这些桶混序命名，比如001，002...

理想情况下，这些数据都是均匀的分到每个桶中，每个小文件(桶)的大小都是100M，这样我们就可以一个个把这些文件加载到内存来，进行快速排序。等所有文件排序好之后，只需要按照桶的顺序输出即可。

那么在非理想情况下，数据绝对有大多时候分均匀的，那么假设有一个桶的里面的数据非常多，深知超过了运行的内存，该怎么办？我们可以继续对这个桶进行分区，直到所有数据都能被读到。

### 计数排序

计数排序是桶排序在特殊情况的一种情况。当要排序的数据n不大的时候，比如最大值是k，可以把这个数据平均分成k个桶。每个桶内的数据值都是相同的，这样省掉了桶内排序的时间。

假设这里有8个考生，分数在0,5之间。这8个考生的成绩我们放入一个数组 A[8] = [2,5,3,0,2,3,0,3]。

考生成绩0到5，我们使用大小为6的数组 C[6] 表示桶，其中下标为分数，不过存储的并不是考生，而是对应考生的个数。结合之前的数据A，我们就能知道C数组的值：C[6] = [2,0,2,3,0,1] 

![](https://static001.geekbang.org/resource/image/ad/c9/adc75672ef33fa54b023a040834fcbc9.jpg)

这样我们就能知道，分数0的为2人，1分的没有，2分的2个人，3分3个人，4分没有，5分的1个人。即小于3分的四个人，大于3分的有1个人，所以我们就能知道在排序后的数组 R[8] 中，会在下标为4,5,6的位置保存下3。

![](https://static001.geekbang.org/resource/image/36/29/361f4d781d2a2d144dcbbbb0b9e6db29.jpg)

那么我们有什么快速的方法能计算出这个结果呢？这个处理很巧妙，我们来看一下：

1.我们先对C[6]数组顺序求和，C[6]的存储情况就变成下面这样(数据存储的是考生的个数，下表对应分数)

![](https://static001.geekbang.org/resource/image/dd/1f/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg)

2.扫描原始数组 A[8]。比如扫到了分数3时，我们可以从C数组中下标3取得数据为7，也就是说目前为止，包括自己在内，小于等于3的有7个，也就是说3是R数组的第7个元素（下标为6）。当3放入R数组后，C数组中对应的值也要减1，即C[3]=6。

一次类推，当我们第二次扫到3时，就会把3放到R数组的第6个元素，C[3]=6-1；如此当我们扫完之后的R数组的数据，就是从小到大排列的。

我们通过代码来进一步说明

```c#
public void BucketSort(int[] a) => SortInternal(a, a.Length - 1);

public void SortInternal(int[] a, int n){
    if(n < 1) return;
    //从原始数查到数据的范围。
    int max = a[0];
    for (int i = 1; i < n; i++) {
    	if (a[i] > max) max = a[i];
    }
    //申请一个临时数组，数组大小为 max+1；
    int[] c = new int[max + 1];
    //初始化
    for(int i = 0; i <= max; i++){
        c[i] = 0;
    }
    //构建一个记录元素个数的数组(也就是上面的分数的学生个数)
    for(int i = 0; i < n; i++){
        c[a[i]]++;
    }
    //依次累加，重新构成一个c数组（上述第1步）
    for(int i = 1; i <= max; i++){
        c[i] = c[i - 1] + c[i];
    }
    //申请临时数组，用来存储排序后的数据
    int[] r = new int[n];
    //计算排序，也就是上述第2步的过程
    for(int i = n - 1; i >= 0; i--){
        //原数组对应的下标
        int index = c[a[i]] - 1;
        r[index] = a[i];
        c[a[i]]--;
    }
    //把排序好的数据r赋值给原始数组a
    for(int i = 0; i < n; i++){
        a[i] = r[i];
    }
}
```



#### 适用范围

计数排序只能用于数据范围不大的排序过程，如果数据范围 K 要比要排序的数据 N 要大很多，就不适合用计数排序（从上面算法分析的c数组组成就能知道）。并且，计数排序只能给非负整数排序，如果要排序其他类型的，要在不该大小的情况下，把负数转化成非负整数。

比如，排序的数组中有负数，数据范围是[-1000,1000]，我们就需要先对每个数 * 1000，转化为非负整数。

### 基数排序（Radix sort）

现在我们有这么一个问题：有10万个手机号码，如何比较这10万个手机号码的大小，因为手机号码有11位，数据范围很大，所以桶排序以及计数排序都不适用了。当然我们可以用时间复杂度为O(nlogn) 的快排和归并排序。但是我们这里要讲一个复杂度为O(n)的基数排序算法。

我们可以这样推演：我们先从手机的高位比较，只要同一位的数字要大，那么剩下的位数就可以不用比较了。

接住稳定算法，我们可以这样比较排序：先按地位进行稳定排序，接着对第2位进行稳定排序，以此类推到最高位。这样拍出来的顺序就是根据位来排序的，就跟初讲排序时，把订单按照金额和时间排序时一样的。手机号码太长，这里不好展示，我们用字符串比较来说明问题

![](https://static001.geekbang.org/resource/image/b0/11/b0b6e18b3dfcb67704cad03ae06ecd11.jpg)

主意，这里的每位比价都是按照稳定算法排序的，如果不是，那么比较到最高位的时候，只关注最高位而低位的不考虑大小关系，那么就跟一开始的从低位开始比较就毫无意义了。

实际上，我们要比较的数据并不是等长的，比如我们要比较英文单词，短的一个字母，长的有45个字母，那么这种情况基数排序还适用么？

其实，我们可以把所有不等长的字母补齐成等长，位数不够我们低位填0，因为根据ASCII，所有字母都是大于0的。这样就不影响原来的大小。即又可以用基数排序了。

所以我们来总结一下：使用基数排序，对数据是有严格要求的。需要分割成独立的“位”来比较，并且每位都有递进关系(保持上一个顺序--稳定排序算法),如果a数据高位要比b数据要打，剩下低位就可以不用比较了。除此之外，每一位数据范围不能太大，要可以用线性排序（桶排序，计数排序），否则时间复杂度就不能为O(n)了。