# Boyer-Moore 算法

在查找字符串的算法当中，BM（Boyer-Moore ）算法是目前被认为最高效的字符串搜索算法，比 KMP 算法性能高 3，4 倍。今天我们就来学习一下 BM 算法

## BM 核心思想

我们把模式串 P 和 主串 T 的匹配过程，看作模式串在主串中不停的往后移。当遇到不匹配的字符串时，BF 算法和 RK 算法的做法是，模式串往后移一位，然后从模式串的第一个字符串重新匹配。

![](https://static001.geekbang.org/resource/image/43/f9/4316dd98eac500a01a0fd632bb5e77f9.jpg)

从图中可以看出，字符 d 与主串对应的字符 c 是不匹配的，所以 BF 和 RK 算法的做法就是往后移一位，然后继续判断。但是我们知道，前面两个字符是公共的，往后移一位肯定还是无法匹配。我们可以直接一次性往后多移 3 位，把模式串移到主串字符 c 的后面。

那么由这种现象，我们是否可以推算出某种规律。根据这种规律，在模式串与主串匹配的过程中，当遇到不匹配的字符时，肯定能多跳过几位的情况。

## BM 算法分析

BM 算法在匹配模式串时不同于之前的都是从前往后匹配，而是从后往前匹配（从结尾到起始点）。如果碰到不能匹配的字符串，我们就把它称之为**坏字符**（主串中的字符） 如图所示

![](https://static001.geekbang.org/resource/image/22/da/220daef736418df84367215647bca5da.jpg)

我们拿坏字符 c 在模式串中查找，发现在模式串不存在这个字符，即与模式串中的所有字符都不匹配。这个时候我们就把模式串在主串中往后移 3（模式串长度） 位的位置，然后接着从模式串尾字符开始比较。

![](https://static001.geekbang.org/resource/image/4e/64/4e36c4d48d1b6c3b499fb021f03c7f64.jpg)

接着我们发现模式串尾字符 d 在主串对应的位置 a 无法匹配，那么我们是不是继续往后移 3 位呢？答案是不行。因为字符 a 在模式串时存在的，存在于位置 0。这种情况下，我们可以让字符 a 对齐——往后移动 2 位。然后从模式串尾部继续匹配主串。

我们继续来看，第一次移位移动了 3 位，第二次移动了 2 位。具体移动多少位，是不是有规律呢？



[BM算法资料1]: http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf



