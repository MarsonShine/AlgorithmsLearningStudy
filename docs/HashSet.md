## 散列表

首先思考一个问题，world 文档中有一个单词检查功能，当你拼接单词错误的时候，world 文档会给你写的单词红色的下划线予以提示。那么这个功能是如何实现的呢？

其实这就用到了我们现在讲的散列表（Hash Table）。

### 什么是散列表

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表是数组的一种拓展，由数组演化而来。**

我们用生活上实际的例子来说明散列表的思想，就以我上大学时候班级学号为例，我们计科班总共有 23 人（人是真的少，并且只有一个班），那么学号暂且是 01 到 23，每个数字就代表，能查到我们班级每个人的信息。所以我们把学号当作数组的下标，学生信息作为值存到数组里。那么当我们查询学号为 x 的学生信息时，只需要将下标 x 的数组元素取出来即可，时间复杂度时 O(1)。

这个例子就用到散裂的思想。学号是自然数，与数组的下标形成一一映射，所以利用了数组下标随机访问，O(1) 的复杂度很容易就能查到学号对应的学生信息。

可能你觉得这个例子还不够直观，那么我们把情景升级一下。

假设学号不可能用这么简单的数字就能代表一个人独一无二的信息，的确是这样，因为别的班级如果学号也是这样，那么你就无法根据学号获取唯一的信息了。我们把学号规则改一下，比如我是 2010 年入学的计科 1001 班，我们把计算机科学专业用 01 表示，比如我的学号是 11，那么综合起来就是 201001100111，最后两位依旧还是原来的学号编号。这个时候我们该如何存储学生信息，才能够通过编号快速查找信息呢？

思路还是跟前面类似。尽管我们不能直接把学号当作下标存储，但是我们可以截取学号的最后两位来当作数组下标，来存取学生信息。当通过学号查询信息的时候，我们通过同样的截取方法获取最后两位作为数组下标，来读取数组中的数据。

这就是典型的散列思想。其中，我们把学生的学号编号（最后两位）叫做键（Key）或关键字。我们用它标识学生。我们把学号转换为数组下标的映射方法称为 **散列函数** 或哈希函数。而通过散裂函数得到的值就是散列值（或叫哈希值）。

通过上述总结出这样的规律：散列表就是用数组支持的下标随机访问的时候，我们通过散列函数把键值转换为散列值，从而在数组中找到对应的位置取出值。

### 散列函数

从上面描述来看，散列函数是至关重要的。

散列函数，顾名思义就是一个函数。我们可以定义为 **hash(key)** ，其中 key 是键值，hash(key) 返回的是散列值。我们把上面的截取最后两位的散列函数用代码表示就是

```c#
int hash(string key){
    //获取最后两位
    string lastTwoChars = key.SubString(key.Length - 2,key.Length);
    //将截取的字符转换为整数
    int hashValue = int.Parse(lastTwoChars);
    return hashValue;
}
```

在刚刚举的例子中，散列函数比较简单，就是简单的数字运算，比较容易想得到。但是假使我们的学号含有字母任意组合怎么办呢？该如何构造散列函数？主要有 3 点基本要求

1. 散列函数计算的散列值是一个非负整数。
2. 如果 key1 = key2，那么 hash(key1) == hash(key2)。
3. 如果 key1 ≠ key2，那么 hash(key1) ≠ hash(key2)。

第一，二点都好理解，第三点要求起来是合乎情理，但是实际情况是我们很难找到一个不同的 key 对应的散列值不同的情况，这几乎是不可能的。就像著名的 MD5、SHA、CRC等哈希算法，也无法完全避免**哈希冲撞**。而且，存储空间有限，也会加大散列冲突的概率。

所以我们无法设计一个无冲突的散列函数。那么我们该如何尽量避免散列冲撞呢？

#### 实数散列

如果键是0到1之间的实数，我们可以将它乘以 M 并四舍五入得到一个 0 至 M-1 之间的索引值。尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将**键表示为二进制数然后再使用除留余数法**。

```c#
static int RealNumberHash(double key, int mask)
{
    // 将实数键转换为二进制数
    long n = BitConverter.DoubleToInt64Bits(key);
    string binaryKey = Convert.ToString(n, toBase: 2);
    int hash = 0;
    foreach (char c in binaryKey)
    {
        hash = (hash * 256 + (c - '0')) % mask;
    }
    return hash;
}
```

#### Horner散列

Horner 算法是一种用于计算字符串散列值的经典算法，它的核心思想是将字符串转换为一系列数字，然后对这些数字进行特定操作。



### 散列冲撞

常用的有两种：开放寻址法（open addressing）和链表法（chaining）。

**开放寻址法**的核心思想是：如果出现了散列冲突，我们将重新探测一个空闲位置，将其插入。那么如何重新探测新的空闲位置？有一个简单的方法：**线形探测（Linear Probing）**

当我们往散列表插入新数据时，如果某个键值经过散列函数的出来的位置已经被占用了，我们就从当前位置依次往后找，直到找到空闲位置为止。要注意，如果到尾部都没有找到空闲位置，那么就会从头还是找。

在散列表中查找元素有点类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就依次顺序往后查找。如果遍历到了空闲位置，还没有找到，就说明要查找的元素不在散列表中。

散列表跟数组一样，不仅支持插入，查找操作，还支持删除操作。对于使用线性探测法解决冲突散列表，删除操作稍微有些特别，不能直接把要删除的元素设置为空，为什么呢？

还记得刚刚我之前查找元素的过程么，散列表在查找目标元素时，一单碰到空闲位置，就会认定这个数不存在于散列表中。但是，这个空闲位置是我们后来删除的，就会导致原来的算法失效。本来存在的数据会被认定不存在，那么这个问题该如何解决呢？

我们可以将要删除的元素标记为 deleted。当线性探测查找时，遇到标记为 deleted 的位置，并不是停下来，而是继续往下探测。

这样可能你们都有一个疑问，当数据量变大时，散列冲突存在的可能性会越来越大，空闲位置就会越来越少，线性探测的事件就会越来越长，在极端情况下，我们可能需要探测整个散列表，所以最坏情况时间复杂度时O(n)。同理，删除和查找时，也会因为线性探测整个散列表，才能找到要删除或查找的元素。

这个时候我们就要用到另外两个探测方法：二次探测（Quadartic probing）和双重散列（Double hasing）。

所谓**二次探测**，其实跟线性探测法类似，只是有步长。线性探测的步长是 1，而它的探测下标就是 hash(key)+0 ，hash(key)+1，hash(key)+2......而二次探测的步长就变成了原来的 “二次方”，也就是说，它的探测下标就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2……

所谓**双重散列**，意思就是说不仅要使用一个散列函数，还要使用一组散列函数：hash(key)，hash2(key)，hash3(key)…… 我们先用第一个散列函数，如果算出来的散列值对应的数组存储位置被占用，在用第二个散列函数，以此类推，直到找到空闲位置。

不管采用哪种方法，当空闲位置越来越少时，散列冲突的概率就会越高。所以为了尽可能保证散列表的操作效率，一定情况下，我们会保持散列表中有一定比例的空闲位置。我们用**装载因子（load factor）**来表示空位的多少。

```
散列表的装载因子 loadfactor = 填入表中的元素个数 ／ 散列表的长度
```

装载因子越大，说明空闲位置越小，冲突越多，散列表的性能就越低。

**链表法**是一种更加常用的解决散列冲突的方法。相比开放寻址法，链表法要简单得多，见图：

![](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)

在散列表中，每个 “桶（bucket）” 或者 “槽（slot）” 会对应一条链表，所有散列值相同的元素我们都放在相同槽位对应的链表中。

当插入的时候，我们根据散列函数计算出对应的桶或槽，然后将其插入相对应的链表即可。所以插入的时间复杂度时 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出桶或槽找到对应的对应的元素并删除。

实际上，这两个操作的时间复杂度根链表的长度有关系，与长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上，k=n/m，其中 n 表示散列表中的个数，m 表示散列表中 “槽” 的个数。

### 如何实现 word 的单词检错功能

常用的英文单词有 20 万个，假设单词的平均长度为 10 个字母，平均一个单词占 10 字节的内存空间，那么 20 万单词就占大约 2 M的内存空间，完全足够。所以我们可以用散列表来记录英文单词。

当用户输入一个单词时，我们拿用户输入的单词与散列表中查找，如果找到，就说明拼写正确。如果没有则说明单词有可能输入错误

### 如何打造一个工业级水平的散列函数

我们知道，设计一个好的散列函数直接决定一个散列表的好坏，决定了散列冲突的概率大小。

**首先散列函数不能设计得太复杂**，因为散列函数这一步不能太耗时，直接影响到了散列表的性能。

其次，**散列函数生成的值要尽量均匀分布**，这样才能最小避免散列冲突。即便是出现冲突，散列到每个槽里的数据比较均匀。

实际工作中，我们还要考虑各种因素。这些因素有**关键字的长度**、**特点**、**分布还有散列表的大小**等等。散列函数各式各样，这里举个几个常用的散列函数的设计方法，有个直观感受。

第一个就是我们的手机号码来标示一个人的基本信息，我们可以用 “数据分析法” 来设计这个散列函数：因为手机号码前面 7 位相同的概率比较高，后 4 位就比较随机，所以我们可以选取手机的后四位作为散列值。这就是 “**数据分析法**”

第二个就是之前的 word 单词检错的实现。这里的散列函数我们可以这样设计：将单词中的 ASCII 码值 “进位” 相加，然后在根据散列表的大小进行求余、取模，作为散列值。比如 “nice” 的散列函数就是：

```
hash("nice")=(('n' - 'a') * 26*26*26 + ('i' - 'a')*26*26 + ('c' - 'a')*26 + ('e' - 'a')) / 78978
```

实际上，散列函数时的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等。

我们之前说了装载因子来空位的多少：loadfactory = n / k ( n 为填入散列表的元素个数，k 代表链表的长度)。

装载因子过大，说明空余位置越来越少，散列冲突的概率就会大大增高。当我们预先知道一个数据集合的规模之后，我们很容易设计出一个相对完美的散列函数出来，但是由于数据时动态的，我们无法知道这个数据集合的大小，是动态变化的（增多或减少）。那么这个时候我们改如何处理呢？

我们可以根据之前说数组时，当数组空间不足时，这时在添加数据那么就用 “动态扩容” 的方式。那么针对散列表，当散列表数据过多，装载因子过大时，我们可以充新一个比之前大一倍的散列表，将数据搬移到心的散列表中。这样装载因子会因为空余位置变多而变得更小。

针对数组的扩容，数据搬移比较简单。但是散列表的扩容数据搬移就显得复杂得多。因为散列表大小变了，数据的存储位置也变了，我们需要重新根据散列函数计算每一个数据的位置。

### 时间复杂度

插入一个数据，最好情况就是不需要扩容，时间复杂度为 O(1)。最坏情况下，散列表装载因子过高，启动扩容，要重新申请内存，重新计算散列值，并且搬移数据。所以时间复杂度为 O(n)。在根据数组的动态扩容时间复杂度分析克制，时间复杂度接近最好情况，也就是 0(1)。

实际上，对于动态散列表，随着时间的删除，散列表的数据会越来越少，空闲空间也会越来越多。如果我们对内存消耗特别敏感的话，我们可以采用动态缩容，我们可以在装载因子等于某个值时，启动动态缩容。当然如果我们更在意执行效率而不是内存的浪费，那么也可以无需缩容。

前面讲到，但散列表的装载因子超过某个阈值时，启动动态扩容。这个阈值需要选择得当。如果太大，导致散列冲突概率变高，太小又浪费空间。所以，阈值的圈定要衡量空间复杂度和时间复杂度。

### 如何避免低效的扩容

大部分情况下，散列表插入一个数据很快，但是当某个特殊情况时，加载因子达到了某个阈值，需要先进行扩容，然后在插入数据。这个时候的速度就很慢了。

举个极端的例子：当前散列表大小为 1G，要想扩容原来的两倍大小，那就需要对 1GB的数据重新计算散列值，并且从原来的数据搬移到新的散列表，这听起来就很耗时。

如果我们的代码直接服务器业务用户，一般情况的插入数据很快，但是极个别操作非常慢的插入操作，这时候就会让用户奔溃。

为了解决这个 “一次性扩容” 导致的问题，我们可以在扩容操作穿插在插入操作当中，分批完成。当装载因子达到阈值时，我们只申请空间，但不将老的数据搬移到新的散列表中。

当有新数据要插入时，我们将新数据插入到散列表中，并且从老的散列表中拿一个数据放置新的散列表中。经过重复这个动作，数据就能一点点的搬移到新的散列表中，而不会因为 “一次性数据搬移” 导致性能很低。

那么这个期间，数据怎么查么？我们约定，在查找数据时，有限着新的散列表，只有当新的散列表中没有值才会找向老的散列表。

### 工业级散列表举例分析

设计一个工业级散列表主要设计以下几个方面：

1. **初始大小**

   如果事先知道数据的大小，我们在初始化时就可以决定空间大小，避免了下次的扩容导致的资源浪费与时间损耗，以便提高初始性能。

2. **装载因子和动态扩容**

   有些语言里面的散列表中的装载因子的 0.75。当散列表中的元素达到 0.75*capacity 时就会启动扩容。

3. **散列冲突解决方法**

   采用 “开放寻址法” 和 “链表法” 

4. **散列函数**

   散列函数不能复杂，追求的是简单，高效，分布均匀。

### 总结

一个好的散列表应该支持以下特点：

1. 支持数据快速增，删，查
2. 内存占用合理，不能浪费过多的内存。
3. 性能稳定，计算情况下，算法也不会退化到令人无法接受的地步。

那么如何设计一个好的散列表呢

1. 设计一个好的散列函数
2. 定义装载因子阈值，并且设计动态扩容策略。
3. 选择合适的解决散列冲突的方。