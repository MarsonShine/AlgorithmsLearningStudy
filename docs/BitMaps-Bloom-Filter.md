# 位图：如何实现网页爬虫的URL去重功能

网页爬虫是很常见切对于搜索引擎中有重要的作用，并且爬取的数据巨大，并且要求速度要快。爬虫的工作原理是，通过解析已经爬取的页面中的链接，然后在爬取这些链接对应的网页。而同一个网页链接可能被包含在不同的页面链接中，所以这就必须要辨别被爬取的页面是否已经爬取过。如果你是一名负责开发网页爬虫的工程师，那么如何高效的爬取网页并去重呢？

最能想到的方法就是用一个哈希表来记录已经爬取过的 URL 网页链接，当爬取到这个页面时，我们在哈希表查询这个页面 URL 是否存在，存在说明是重复爬取，没有说明是新 URL，并存到哈希表中。

## 算法解析

这个问题主要是处理解析页面的 URL，需要支持的操作有两个，添加 URL 和 查询 URL。除了这两个功能性的要求方面之外，在性能方面要尽量的高效，节省内存空间。

回想我们之前学习到的数据结构与算法，我们用什么数据结构满足这一点呢？显然 红黑树，散列表，跳表这些动态的数据结构，都能快速的支持插入，查询数据，但是对内存消耗方面，在不在接受的范围内呢？

我们拿散列表举例。假设我们要爬取 10 亿个网页（像 Google，百度这样的搜索引擎，爬取的资源只会更多），为了去重，我们得维护一个 10 亿大小的散列表。那么要消耗多少内存呢？

我们假设一个 URL 的平均长度为 64 字节，那么这 10 亿个 URL，内存大约 60G 的内存空间。**因为散列表必须维持较小的装载因子，才能保证不会出现过程的哈希冲突，导致操作性能的下降**。**而且，用链表法解决散列冲突，还要存储链表指针**，如果构建这 10 亿个 URL 的散列表，所需的内存一定会高于 60G，甚至有可能会超过 100G。

对于大型的爬虫系统，即便是要求 100G 内存要求也不高，我还可以用分治法，用多台机器（比如用 20 台机器内存为 8G 的服务器）来存储这 10 亿个网页链接。

对于爬虫系统去重的问题，其实上面的思想已经可以用于生产环境工作了。不过，作为一个有追求有要求的工程师，我们应该考虑，在添加，查询的操作下效率以及内存消耗方面能不能有更好的优化方法呢？

你可能会说，用散列表的话，添加，查询数据已经是 O(1)，还能有优化空间么？事实上，我们平常所讲的时间复杂度是个根据数据规模的渐进时间变化趋势，这不能度量在一个特定的环境内的具体时间消耗。

我们平常所讲的时间复杂度都是忽略系数，常数和低阶。

如果一个时间复杂度的系数为 10，那么我们在优化过程中，能把这个系数 10 优化成 1，那时间消耗也会比之前少 10 倍，这是一个很有必要的优化。

我们用链表法解决散列冲突问题，散列表中存储的 URL，在查询的时候，通过哈希函数定位到散列表中具体的链表，还要在这个链表中查询这个 URL。这个操作是比较耗时的，主要原因有亮点。

一方面，链表中的结点存储在内存中不是连续的，所以不能一下子存储到 CPU 高速缓存中，所以数据访问性能会大打折扣。

另一方面，在查询的是字符串而不是数字，在比较时，我们用的字符串比配。显然匹配字符串的性能明显没有数字效率高。所以针对这两个方面，还是有优化空间的。

对于内存消耗的方面的优化，除了散列表之外，其实还有一个算法能让内存有明显的提升，那就是**布隆过滤器（Bloom Filter）**。

在讲布隆过滤器之前，我们先讲**位图（Bit Maps）**，这是另一种数据结构。因为布隆过滤器就是基于位图的，是对位图的一种改进。

我们先来看一个简单的问题。我们有 1 千万个整数，整数在 1 到 1亿之间。如何快速判断一个数是否在这个 1 千万个数据里面？

我们还是用散列表。不过这次用到的是特殊的散列表——位图。我们申请 1 亿大小的，数据类型为布尔类型的数组。我们将这 1 千万个整数作为下标，将对应的值设置成 true 或者 false。比如数字 5 对应数组的下标 5 的数组的值设置为 true，即 array[5] = true。

当我们查询这个数是否存在时，只需要在这个数组中对应这个数的下标的值是否等于 true 就知道是否存在了。

不过，很多语言提供的布尔类型，大小都是 1 字节的，并不能节省太多空间。实际上，标识有或没有，true 或 false 只要 1 bite 即可。**那么如何通过编程语言，来实现一个二进制位呢？**

这里就要用到位运算了。我们可以借助编程语言中提供的数据类型，比如 int、long、char 等类型，通过位运算，用其中某个位来表示某个数字。通过以下代码更好理解：

```c#

```

> 注意：不同的语言 / 平台不同的数据类型所占字节是有所差异的，Java 中 char 类型占 16bit，2 字节。C# 中如 int 分系统平台位数，32 位系统占 4 字节，64 位系统占 8 字节。

从刚刚位图结构的讲解中，可以发现，通过数组下标来定位数据，所以查询效率非常高。而且，每个数字是通过一个二进制位表示的，在范围不大的情况下，所需内存是非常小的。

就说刚才的例子，如果用散列表存储 1 千万的数据，数据是 32 位的整形，也就是每个数字需要 4 个字节存储空间，总共需要 40 MB 的内存空间。如果我们通过位图来表示，数字范围在 1 到 1亿之间，只需要 1 亿二进制位，也就是大约只需要 12 MB 的内存空间即可。

关于位图我们就讲完了，是不是很简单？不过这里有个限制条件，那就是数字范围在 1 到 1亿之间，如果范围变大一些，1 到 10 亿之间的 1 千万的数据，内存却翻了 10 倍，所需内存即 120MB，不降反升。

这种情况下，布隆过滤器就是为了解决这个问题的，对位图来说的数据结构一种改进。