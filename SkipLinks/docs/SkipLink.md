## 跳表

前面提到的二分法算法已经二分法的变形算法，都是依赖于特定的数据存储结构来查询的——数组结构，那么是不是改成链表结构就不行了么？其实这就是我们要说的 “跳表” ，就是在存储结构为链表，有二分法相关思想演变过来的算法。我们知道，红黑树（Red-black tree）也能搞笑的添加，删除，查询，但是实际上，Redis 内部就是用的跳表取代的红黑树。

### 如何理解跳表

对于一个单链表来说，即便数据是从小到大排序的，当你查询指定数据时，都要从 head 开始遍历，时间复杂度是 O(n) ，效率是很低的。

如果我们对这些顺序链表监理一级 “索引” ，查找起来是不是就会快很多呢？每两个节点提取一个节点作为上一级，我们把抽取出来的那一级叫做索引或索引层。如图所示，down 代表 down 指针，指向下一级节点

![](https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg)

如果我们现在要查找元素 16。我们可以现在索引层遍历，等到 13 的时候，发现下一个节点是 17 ，那么就知道 16 肯定在 索引 13 和 17 之间。于是就根据索引层的范围回到原来的初始链表继续遍历。这个时候我们只要遍历两次就可以了。

从这个例子看出，当加一层索引层之后，查找一个元素所需遍历的节点变少了，也就是查询效率提高了，那么我们在此之上继续提取节点作为索引呢？效率会不会更高？

于是跟前面建立索引层的方式一样，我们在第一级索引层之上继续提取两个节点为一个上一级。并且重新查找元素 16，我们看有什么变化。

![](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

当我们遍历第二级索引，便利到 13 时就可以回复到原始链表继续遍历，这样就只需要遍历 6 个节点即可，遍历的节点又变少了。

所以我们知道，当数据越多，提取出来的索引层变多，可遍历的节点也会相应变少，从而提高查询效率。

这里讲的增加索引层的方式就是跳表。

### 时间复杂度

这个复杂度一眼还看不错来，尽管之前我们做了那么多次联系，我们先把问题分解一下，如果链表有 n 个节点，那么会有多少个索引呢？

按照之前说过的以及图画的内容，我们知道每两个节点就抽取成一个节点作为上级节点，所以第一级索引层有 n/2 个，第二级索引有 n/4 个，第三级索引有n/8 个。以此类推，第 k 级索引的个数为 n/2^k。

假设索引有 h 级，最高级的索引有两个结点。通过上述公式，我们可以得到 n/2^h = 2，从而根据对数公式得知 h = log2n - 1，如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在查询某个数据的时候，如果每一层都要遍历 m 个节点，那么在跳表中查询一个数据的时间复杂度就是 O(mlogn)。