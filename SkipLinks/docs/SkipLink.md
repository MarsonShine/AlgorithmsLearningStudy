## 跳表

前面提到的二分法算法已经二分法的变形算法，都是依赖于特定的数据存储结构来查询的——数组结构，那么是不是改成链表结构就不行了么？其实这就是我们要说的 “跳表” ，就是在存储结构为链表，有二分法相关思想演变过来的算法。我们知道，红黑树（Red-black tree）也能搞笑的添加，删除，查询，但是实际上，Redis 内部就是用的跳表取代的红黑树。

### 如何理解跳表

对于一个单链表来说，即便数据是从小到大排序的，当你查询指定数据时，都要从 head 开始遍历，时间复杂度是 O(n) ，效率是很低的。

如果我们对这些顺序链表监理一级 “索引” ，查找起来是不是就会快很多呢？每两个节点提取一个节点作为上一级，我们把抽取出来的那一级叫做索引或索引层。如图所示，down 代表 down 指针，指向下一级节点

![](https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg)

如果我们现在要查找元素 16。我们可以现在索引层遍历，等到 13 的时候，发现下一个节点是 17 ，那么就知道 16 肯定在 索引 13 和 17 之间。于是就根据索引层的范围回到原来的初始链表继续遍历。这个时候我们只要遍历两次就可以了。

从这个例子看出，当加一层索引层之后，查找一个元素所需遍历的节点变少了，也就是查询效率提高了，那么我们在此之上继续提取节点作为索引呢？效率会不会更高？

于是跟前面建立索引层的方式一样，我们在第一级索引层之上继续提取两个节点为一个上一级。并且重新查找元素 16，我们看有什么变化。

![](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

当我们遍历第二级索引，便利到 13 时就可以回复到原始链表继续遍历，这样就只需要遍历 6 个节点即可，遍历的节点又变少了。

所以我们知道，当数据越多，提取出来的索引层变多，可遍历的节点也会相应变少，从而提高查询效率。

这里讲的增加索引层的方式就是跳表。

### 时间复杂度

这个复杂度一眼还看不错来，尽管之前我们做了那么多次联系，我们先把问题分解一下，如果链表有 n 个节点，那么会有多少个索引呢？

按照之前说过的以及图画的内容，我们知道每两个节点就抽取成一个节点作为上级节点，所以第一级索引层有 n/2 个，第二级索引有 n/4 个，第三级索引有n/8 个。以此类推，第 k 级索引的个数为 n/2^k。

假设索引有 h 级，最高级的索引有两个结点。通过上述公式，我们可以得到 n/2^h = 2，从而根据对数公式得知 h = log2n - 1，如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在查询某个数据的时候，如果每一层都要遍历 m 个节点，那么在跳表中查询一个数据的时间复杂度就是 O(m*logn)。

那么 m 的值是多少呢？按照我们上面的数据结构（两个节点作为一个上级结点），那么每级索引最多会遍历 3 个节点元素。

通过分析，我们知道在跳表中查询任意的数据的时间复杂度都是 O(logn)。这个查询时间复杂度跟二分查找是一样的。换句话说，我们是基于单链表实现了二分查找，这种提高了查询效率是有代价的，因为建立了很多个索引，所以这是典型的拿空间换时间的设计思路。

### 跳表是不是很浪费内存

比起单纯的单链表，跳表需要建立很多的索引层，肯定需要消耗更多的内存空间。那么到底要消耗多少内存空间呢？我们来分析一下空间复杂度。

我们假设原始链表大小为 n，那第一级索引有 n/2 个结点，第二级索引有 n/4 个，第三级索引有 n/8 个，以此类推，每上升一级索引就减少一半的元素，直到剩下 2 个结点。

我们把每级的索引结点数写出来，发现是个等比数列：

```c#
//原始链表大小为n，每两个结点为一个结点，每层索引数是
n/2,n/4,n/6...8,4,2
//a1=n/2;q=1/2;an=2;
```

根据等比求和公式：

![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3063566503,3480622283&fm=58)

空间复杂度为 O(n)，也就是说 n 个结点的单链表构造跳表，需要额外 n 个结点的存储空间。那么我们有没有办法降低索引占用的内存空间呢？

我们前面分析的是以抽取 2 个结点为一个上级结点，那么我改成每 3,5 个结点，抽取成一个上级结点为一个索引，是不是就不用那么多索引结点了呢？

![](https://static001.geekbang.org/resource/image/0b/f7/0b0680ecf500f9349fc142e1a9eb73f7.jpg)

那么我们继续用等比求和公式得知 n/3+n/9+n/27+...+27+9+3+1 = n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽成一个索引结点，要减少一半的索引结点的存储空间。

在实际开发中，我们不必在意索引占用的内存空间，因为在实际开发中原始链表中存储的可能是大对象，而索引记录的是代表这个对象元素的指针或几个键值，空间比较起来很小。

### 高效的动态删除与插入

我们知道，链表的插入删除操作是很快的，时间复杂度为 O(1)。但是这里要保证插入的数据是有序的，所以先查找要插入元素的位置，这个查询操作就比较耗时。

对于纯粹的单链表，需要遍历每个元素来找到插入的位置。但是对于跳表来说，查询相对应的位置跟上面查询的方法是类似的，时间复杂度是 O(logn)。

还是以上面的图为例，假设我们要插入元素 6。那么我们在索引层查找对应的区间就能往下一级索引继续遍历知道找到对应的区间，遍历元素，最终找到插入的位置。

那么我们来看看删除操作。

当我们不停的往跳表中插入数据，我们不更新索引，就有可能出现在某个索引之间的元素会变得特别多。极端情况下，可能会退化成但单链表。

![](https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg)

作为一种动态数据结构，我们需要用某种手段来维护这两者（索引和链表长度）之间的平衡。也就是说链表节点多了，索引节点就相应的增加一些来避免复杂度退化，查询删除插入操作性能降低。

**比如红黑树，AVL 平衡二叉树就是通过左右旋的方式来保持左右子树的大小平衡。而跳表是通过随机函数来维护这种平衡性**

当我们往跳表中添加一个数据时，我们可以选择同时将这个数据作为索引插入索引层。如何选择加入那些索引层呢？

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成数字 K，那我就将第一级到 K 级的索引层都加上这个数据。

![](https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg)

### 跳表的代码实现

### 为什么 Redis 中的有序集合是通过跳表实现的

严格的讲，Redis 还用到散列表，这节先忽略这部分。在 Redis 的开发手册中，有序集合主要支持的核心操作有下面几点：

1. 插入一个数据
2. 查找一个数据
3. 删除一个数据
4. 按照区间查找数据（比如 [100,1000]）
5. 迭代输出有序序列

其中，插入、查找、删除操作用红黑树数据结构跟用跳表是一样的，时间复杂度都是 O(logn)。但是按照区间查找数据，红黑树的查询效率就不如跳表了。

对于区间查找，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始跳表中依次遍历这区间的元素就可以查到目标元素了。这样做非常高效。

当然 Redis 之所以用跳表来实现有序集合还有其他方面的原因，比如跳表代码易实现，易懂，可读性好。