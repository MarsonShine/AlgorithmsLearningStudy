# 队列

我们知道CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程会产生线程上下文切换，导致处理性能下降。

> 注意：线程上下文切换为什么会导致性能显著降低呢？从《CLR via C#》中线程部分就涉及到。首先是线程的开销：1. **线程内核对象**，OS给每个线程分配并初始化这种数据结构。其中包含一组对线程进行描述的属性，还包括线程上下文（thread context）；2. **线程环境块**（TEB），它在用户模式（应用程序能快速访问的内存地址空间）中分配和初始化内存块。TEB还包含“线程本地存储”数据。3. **用户模式栈**，存储方法的局部变量和实参，还包括当前方法返回的时，线程应该从什么地方继续执行。4. **内核模式栈**，当调用系统级别的函数与功能时，就会用用户模式切换到内核模式，这时windows会把它们从线程的用户模式栈复制到内核模式栈。5. DLL线程连接和线程分离；
>
> 上下文切换概念：单CPU计算机一次只能做一件事情，所以windows必须在系统中共享物理CPU。当CPU给一个线程分配一个CPU。那个线程能运行一个“时间片”的长度。时间片到期，windows就会上下文切换到另一个线程
>
> 上下文切换过程：1. 将CPU寄存器和值保存到当前正在运行的***线程内核对象***内部的一个上下文结构中。2. 从现有线程集合中选出一个线程提供调度。如果该线程由另一个进程拥有，windows在执行任何代码或接触任何数据之前，CPU必须切换虚拟地址空间。3. 将线程上下文结构中的值加载到CPU寄存器中。

## 队列的理解

队列就好比是正在排队上车，队列中最先进来的总是第一个上车，排在最后的是最后一个上车的。

这是一种典型的**先进先出（FIFO）**场景。

由前面说道的Stack知道，栈只有入栈和出栈两个操作。队列也是如此，只有两个操作：**入队(Enqueue)**，数据进来放到队列尾部。**出队(Dequeque)**,从队列头取出一个元素。

队列有很多种特性，比如：环形队列，循环队列，阻塞队列，并发队列等

### 顺序队列和链式队列

队列跟栈是一样的，顺序队列（由数组结构构成）；链式队列（用链表构成）



