# 栈

栈主要包含“入栈”和“出栈”两个操作，也就是在栈顶插入一个数据和在栈顶删除一个数据。

## 栈的实现

栈的实现有两种：

1. 由数组实现的顺序栈
2. 由链表实现的链式栈

## 栈的时间/空间复杂度

不管是顺序栈还是链式栈，我们存储数据只需要大小为n的数组就够了。在入栈和出栈，只需要靠一两个临时变量的存储空间，所以空间复杂度是O(1)。

> 注意：这里存储数据需要一个大小为n的数组，不是说明空间复杂度就为O(n)。因为，n这个空间是必须的，无效省掉。所以我们平常说的空间复杂度是指除了原本数据的存储空间外，算法运行还需要额外的存储空间。

不管是顺序栈还是链式栈，入栈，出栈只涉及到栈顶个别数据的操作，所以时间复杂度都是O(1)。

## 支持动态扩容的顺序栈

由于顺序栈的实现原理是由数组构成的，所以根据数组的动态扩容来实现顺序栈的动态扩容——当数组空间不够时，申请更大的数组内存（一般是原来的2倍大小），将原来数组中的数组拷贝过去。这样就是实现了顺序栈的动态扩容。

### 分析时间/空间复杂度

对于出栈操作来说，不涉及到内存的重新申请和数据迁移，所以出栈的时间复杂度任然是O(1)。入栈操作情况就不一样了。当栈有空间时，其时间复杂度为O(1)。但是当空间不够时，就需要内存申请和数据拷贝迁移，所以时间复杂度就为O(n)。即最好情况时间复杂度为O(1)，最差情况为O(n)。那么平均时间复杂度为多少？

用摊还分析法来分析，事先做个假设

- 栈空间不够时，重新申请一个原来2倍的数组
- 简化分析，只有入栈没有出栈
- 定义不涉及内存迁移的入栈操作为simple-push操作，时间复杂度为O(1)。

如果当前栈大小为K，并且已满，当再有新的数据入栈时，就需要申请两倍大小的数组内存，并做了K次数据迁移操作，然后继续入栈。但是接下来的K-1次操作都不设计内存申请和数据迁移操作，所以这K-1次操作都只需要一个simple-push就可以完成。

![](https://static001.geekbang.org/resource/image/c9/bb/c936a39ad54a9fdf526e805dc18cf6bb.jpg)

这K次入栈操作，总共涉及到了K次数据迁移，以及K次simple-push操作。将k个数据迁移均摊到K次入栈操作，那么每次入栈操作就只需要一个数据迁移和一个simple-push操作。以此类推，入栈操作的平均时间复杂度为O(1)。

## 栈在函数调用的应用

操作系统给每个线程都分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时用到的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

下面代码与图说明了函数调用栈的情况

```c++
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
```

main()函数调用add()函数，获取计算结果与临时变量a相加，最后打印res的值。其图显示的是调用add函数时，函数调用栈情况

![](https://static001.geekbang.org/resource/image/17/1c/17b6c6711e8d60b61d65fb0df5559a1c.jpg)

## 栈在表达式求值中的应用

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个保存运算符的栈。表达式是从左往右遍历表达式，当遇到数组，我们直接push操作数栈。当遇到运算符，就与运算符栈的栈顶元素进行比较。

如果比运算符栈顶元素优先级高，就将当前运算符压栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈顶元素取两个操作数，进行计算，在把计算结果压入操作数栈，继续比较。

![](https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg)