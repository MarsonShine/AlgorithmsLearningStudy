# 字符串查找匹配算法

在平常的开发中，我们经常用到的功能就包含字符串查找、根据提供的子字符串来在源字符串中匹配。实现的算法也有很多中，我们这节主要介绍两种实现方法：BF 算法和 PK 算法。

## BF（暴力匹配） 查找匹配

BF 全称是 “Brute Force”，暴力匹配算法，顾名思义，这种算法匹配方式很暴力，因为它很简单易懂，但伴随着是性能的不高。

BF 算法：**我们在主串中，检查位置从起始位置分别从0，1，2…n-m 且长度为 m 的 n-m+1 个子串，看有没有根模式串匹配的。**

举个例子，这里有主串 “aaaaa....aaaa” ，模式串是 “aaaab”（m=5）。那么我们匹配模式串，都对比 m 个字符，要对比 n-m+1 次，所以，这种算法的的最坏时间复杂度为 O(m*n)。

虽然时间复杂度非常高，但是在实际开发中，它却是一个比较常用的字符串匹配算法。

第一，因为在实际开发中，基本上不会碰到主串非常长。并且在匹配到不能匹配的字符的时候，就可以停止了，而不会把 m 个字符都比对一次。

第二，BF 算法代码实现非常简单。不容易出错，如果有 bug 也容易修复。

## RK 算法

我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希是一个数字，数字之间的比较是很快的，所以 RK 算法要比 BF 算法快很多。

在 通过哈希算法求子串的哈希值时，我们还是需要遍历子串中的每个字符。尽管在模式串与子串比较的效率提高了，但是整体效率并没有提高。有没有办法可以提高哈希算法子串哈希值的效率呢？

这里引用极客时间专栏中的描述

> 假设要匹配的字符集只包含 K 个字符，我们可以用一个 K 进制来表示一个子串，这个K 进制树转化成十进制，作为子串的哈希值。
>
> 比如要处理的字符只包含 a-z 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a-z 这26个字母映射到 0-25个数字，就是 0 表示a，1 表示b以此类推，z 表示 25。

![](https://static001.geekbang.org/resource/image/d5/04/d5c1cb11d9fc97d0b28513ba7495ab04.jpg)

上面的 “657” 通过右边十进制算出来的，“cba” 则同样依次规则根据十六进制计算得知。

这种哈希算法有一个特点，在主串中，相邻的两个子串的哈希值的计算公式有一定的规律。

![](https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg)

由此我们可以得出这样的规律：相邻的两个子串 s[i-i] 和 s[i] （i 表示子串在主串中的起始位置，子串的长度为 m），对应的哈希值计算公式有交集，即我们可以根据 s[i-1] 的哈希值很快的计算出 s[i] 的哈希值。用公式就是：



