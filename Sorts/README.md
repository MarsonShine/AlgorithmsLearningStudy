# 排序

## 如何分析一个“排序算法”

排序有很多种，常用的就有：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、堆排序、基数排序、桶排序等。不常见的又比如猴子排序、睡眠排序、面条排序等

如何分析一个排序算法呢，有三个因素要考虑。

### 排序算法的执行效率

1. **最好情况、最坏情况、平均情况时间复杂度**；因为一组数据可能已经就是排过序了（完全有序），有的是完全无序。有序度不同的数据，排序的执行时间肯定是有影响的，我们要知道在不同排序度的性能情况。
2. **时间复杂度的系数、常数、低阶**；时间复杂度反应的数据规模n很大的时候的一个增长趋势，所以在这种情况会忽略系数，常数，低阶。但是在我们实际开放中，我们几乎很少有这种大规模的数据。所以在小规模数据时，特别是在同阶对比时间复杂度时，系数、常数、低阶都要考虑进来。
3. **比较次数和交换（或移动）次数**；基于比较的排序算法的执行过程，会有两个操作，一种是元素的比较大小，另一种是元素交换或移动。所以在比较时间复杂度的执行效率的时候，应该把比较次数和移动或交换的次数也考虑进去。

### 排序算法的内存消耗

衡量一个算法的内存消耗，可以用空间复杂度。不过，针对排序算法的空间复杂度，还有一个概念：**原地排序（Soreted in place）**。原地排序算法，就是特指空间复杂为O(1)的排序算法。冒泡、插入、选择排序都是原地排序算法。

### 排序算法的稳定性

什么是算法的稳定性：就是在一个集合中，存在相同的值的元素，经过排序后，相等元素之间原有的顺序没有发生改变，我们就称这个为稳定性。同时我们把这种算法称为**稳定排序算法**。先从简单的整形数组举例：

[2,9,3,4,8,3] 按照排序之后之后为 [2,3,3,4,8,9]

这里面有两个3，经过排序之后，如果这两个3顺序没有改变，这个就是排序就是稳定的。相反，如果这两个3的顺序改变了那就非稳定的。当然从整数上是看不出到底哪个3在前，哪个3在后；在举个平常业务上的例子，这里有一个订单集合，要求按照订单金额从小到大的顺序排序，其中金额相同的订单按照订单时间排序。

“先按照订单时间排序，然后遍利排序后的集合，把金额相同的订单再按照订单时间排序“

这种实现起来比较容易理解，但是复杂。

但是我们可以借助稳定排序算法，能够在保持第一次排序的顺序进行第二次排序。具体思路是：我们先按照订单时间排序，第二次排序我们用稳定排序算法把订单金额进行排序，所以经过第二次排序之后，相同的订单仍然保持以时间早晚的顺序排序。